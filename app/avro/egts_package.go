// Code generated by github.com/actgardner/gogen-avro. DO NOT EDIT.
/*
 * SOURCE:
 *     egtspackage.avsc
 */

package avro

import (
	"github.com/actgardner/gogen-avro/compiler"
	"github.com/actgardner/gogen-avro/container"
	"github.com/actgardner/gogen-avro/vm"
	"github.com/actgardner/gogen-avro/vm/types"
	"io"
)

type EgtsPackage struct {

	// IMEI of the device that sent this data
	Imei string

	// Client ID assigned to receiver device
	ClinetId int32

	// Identifier of the data packet
	PacketID int32

	// Timestamp of the measurement
	MeasurementTimestamp int64

	// Timestamp of receiveing the data from device
	ReceivedTimestamp int64

	// Device's latitude at the moment of measurement
	Latitude int64

	// Device's longitude at the moment of measurement
	Longitude int64

	// Device's speed at the moment of measurement
	Speed int32

	// Position dilution of precision
	Pdop int32

	// Horizontal dilution of precision
	Hdop int32

	// Vertical dilution of precision
	Vdop int32

	// Number of satelites that were used to detect device position
	NumOfSatelites   int32
	NavigationSystem NavigationSystem

	// Angle (in degrees) between north meridian and device's moving direction (clockwise). Value is in [0, 359] degrees range
	Direction int32

	// Values red from analog sensors connected to analog inputs at the moment of measurement. Some analog inputs can be used for counting signals from discrete inputs
	AnalogSensors *UnionArrayAnalogSensorNull

	// Values red from liquid sensors connected to liquid sensors inputs at the moment of measurement
	LiquidSensors *UnionArrayLiquidSensorNull
}

func NewEgtsPackageWriter(writer io.Writer, codec container.Codec, recordsPerBlock int64) (*container.Writer, error) {
	str := &EgtsPackage{}
	return container.NewWriter(writer, codec, recordsPerBlock, str.Schema())
}

func DeserializeEgtsPackage(r io.Reader) (*EgtsPackage, error) {
	t := NewEgtsPackage()

	deser, err := compiler.CompileSchemaBytes([]byte(t.Schema()), []byte(t.Schema()))
	if err != nil {
		return nil, err
	}

	err = vm.Eval(r, deser, t)
	return t, err
}

func NewEgtsPackage() *EgtsPackage {
	return &EgtsPackage{}
}

func (r *EgtsPackage) Schema() string {
	return "{\"fields\":[{\"doc\":\"IMEI of the device that sent this data\",\"name\":\"imei\",\"type\":\"string\"},{\"doc\":\"Client ID assigned to receiver device\",\"name\":\"clinetId\",\"type\":\"int\"},{\"doc\":\"Identifier of the data packet\",\"name\":\"packetID\",\"type\":\"int\"},{\"doc\":\"Timestamp of the measurement\",\"name\":\"measurementTimestamp\",\"type\":\"long\"},{\"doc\":\"Timestamp of receiveing the data from device\",\"name\":\"receivedTimestamp\",\"type\":\"long\"},{\"doc\":\"Device's latitude at the moment of measurement\",\"name\":\"latitude\",\"type\":\"long\"},{\"doc\":\"Device's longitude at the moment of measurement\",\"name\":\"longitude\",\"type\":\"long\"},{\"doc\":\"Device's speed at the moment of measurement\",\"name\":\"speed\",\"type\":\"int\"},{\"doc\":\"Position dilution of precision\",\"name\":\"pdop\",\"type\":\"int\"},{\"doc\":\"Horizontal dilution of precision\",\"name\":\"hdop\",\"type\":\"int\"},{\"doc\":\"Vertical dilution of precision\",\"name\":\"vdop\",\"type\":\"int\"},{\"doc\":\"Number of satelites that were used to detect device position\",\"name\":\"numOfSatelites\",\"type\":\"int\"},{\"documentation\":\"Navigation system identifier\",\"name\":\"navigationSystem\",\"type\":{\"name\":\"NavigationSystem\",\"namespace\":\"com.projavt.ecology.schema\",\"symbols\":[\"Uknown\",\"GLONASS\",\"GPS\",\"Galileo\",\"Compass\",\"Beidou\",\"DORIS\"],\"type\":\"enum\"}},{\"doc\":\"Angle (in degrees) between north meridian and device's moving direction (clockwise). Value is in [0, 359] degrees range\",\"name\":\"direction\",\"type\":\"int\"},{\"doc\":\"Values red from analog sensors connected to analog inputs at the moment of measurement. Some analog inputs can be used for counting signals from discrete inputs\",\"name\":\"analogSensors\",\"type\":[{\"items\":{\"fields\":[{\"doc\":\"Ordinal number of sensor\",\"name\":\"sensorNumber\",\"type\":\"int\"},{\"doc\":\"Value red from sensor. Meaning is this value depends on type of the input. if analog device is connected to the input, value is millivolts. If input is used for counting discrete impulses, value is the number of impulses\",\"name\":\"value\",\"type\":\"int\"}],\"name\":\"AnalogSensor\",\"namespace\":\"com.projavt.ecology.schema\",\"type\":\"record\"},\"type\":\"array\"},\"null\"]},{\"doc\":\"Values red from liquid sensors connected to liquid sensors inputs at the moment of measurement\",\"name\":\"liquidSensors\",\"type\":[{\"items\":{\"fields\":[{\"doc\":\"Ordinal number of sensor\",\"name\":\"sensorNumber\",\"type\":\"int\"},{\"doc\":\"Value is set if error occurred during reading value from liquid sensor\",\"name\":\"errorFlag\",\"type\":\"string\"},{\"doc\":\"This value is set if liquid sensor measures level of the liqid in a vessel. Otherwise value is 0\",\"name\":\"valueMillimeters\",\"type\":\"int\"},{\"doc\":\"This value is set if liquid sensor measures volume of the liqid in a vessel. Otherwise value is 0\",\"name\":\"valueLitres\",\"type\":\"int\"}],\"name\":\"LiquidSensor\",\"namespace\":\"com.projavt.ecology.schema\",\"type\":\"record\"},\"type\":\"array\"},\"null\"]}],\"name\":\"EgtsPackage\",\"namespace\":\"com.projavt.ecology.schema\",\"type\":\"record\"}"
}

func (r *EgtsPackage) SchemaName() string {
	return "com.projavt.ecology.schema.EgtsPackage"
}

func (r *EgtsPackage) Serialize(w io.Writer) error {
	return writeEgtsPackage(r, w)
}

func (_ *EgtsPackage) SetBoolean(v bool)    { panic("Unsupported operation") }
func (_ *EgtsPackage) SetInt(v int32)       { panic("Unsupported operation") }
func (_ *EgtsPackage) SetLong(v int64)      { panic("Unsupported operation") }
func (_ *EgtsPackage) SetFloat(v float32)   { panic("Unsupported operation") }
func (_ *EgtsPackage) SetDouble(v float64)  { panic("Unsupported operation") }
func (_ *EgtsPackage) SetBytes(v []byte)    { panic("Unsupported operation") }
func (_ *EgtsPackage) SetString(v string)   { panic("Unsupported operation") }
func (_ *EgtsPackage) SetUnionElem(v int64) { panic("Unsupported operation") }
func (r *EgtsPackage) Get(i int) types.Field {
	switch i {
	case 0:
		return (*types.String)(&r.Imei)
	case 1:
		return (*types.Int)(&r.ClinetId)
	case 2:
		return (*types.Int)(&r.PacketID)
	case 3:
		return (*types.Long)(&r.MeasurementTimestamp)
	case 4:
		return (*types.Long)(&r.ReceivedTimestamp)
	case 5:
		return (*types.Long)(&r.Latitude)
	case 6:
		return (*types.Long)(&r.Longitude)
	case 7:
		return (*types.Int)(&r.Speed)
	case 8:
		return (*types.Int)(&r.Pdop)
	case 9:
		return (*types.Int)(&r.Hdop)
	case 10:
		return (*types.Int)(&r.Vdop)
	case 11:
		return (*types.Int)(&r.NumOfSatelites)
	case 12:
		return (*types.Int)(&r.NavigationSystem)
	case 13:
		return (*types.Int)(&r.Direction)
	case 14:
		r.AnalogSensors = NewUnionArrayAnalogSensorNull()
		return r.AnalogSensors
	case 15:
		r.LiquidSensors = NewUnionArrayLiquidSensorNull()
		return r.LiquidSensors

	}
	panic("Unknown field index")
}
func (r *EgtsPackage) SetDefault(i int) {
	switch i {

	}
	panic("Unknown field index")
}
func (_ *EgtsPackage) AppendMap(key string) types.Field { panic("Unsupported operation") }
func (_ *EgtsPackage) AppendArray() types.Field         { panic("Unsupported operation") }
func (_ *EgtsPackage) Finalize()                        {}

type EgtsPackageReader struct {
	r io.Reader
	p *vm.Program
}

func NewEgtsPackageReader(r io.Reader) (*EgtsPackageReader, error) {
	containerReader, err := container.NewReader(r)
	if err != nil {
		return nil, err
	}

	t := NewEgtsPackage()
	deser, err := compiler.CompileSchemaBytes([]byte(containerReader.AvroContainerSchema()), []byte(t.Schema()))
	if err != nil {
		return nil, err
	}

	return &EgtsPackageReader{
		r: containerReader,
		p: deser,
	}, nil
}

func (r *EgtsPackageReader) Read() (*EgtsPackage, error) {
	t := NewEgtsPackage()
	err := vm.Eval(r.r, r.p, t)
	return t, err
}

// Code generated by github.com/actgardner/gogen-avro. DO NOT EDIT.
/*
 * SOURCE:
 *     measurementpackage.avsc
 */

package avro

import (
	"github.com/actgardner/gogen-avro/compiler"
	"github.com/actgardner/gogen-avro/container"
	"github.com/actgardner/gogen-avro/vm"
	"github.com/actgardner/gogen-avro/vm/types"
	"io"
)

type MeasurementPackage struct {

	// IMEI of the device that sent this data
	Imei *UnionNullString

	// Unique record identifier
	Guid string

	// Client ID assigned to receiver device
	ClinetId int64

	// Identifier of the data packet
	PacketID int64

	// Timestamp of the measurement
	MeasurementTimestamp int64

	// Timestamp of receiveing the data from device
	ReceivedTimestamp int64

	// Device's latitude at the moment of measurement
	Latitude *UnionNullDouble

	// Device's longitude at the moment of measurement
	Longitude *UnionNullDouble

	// Device's speed at the moment of measurement
	Speed *UnionNullInt

	// Position dilution of precision
	Pdop *UnionNullInt

	// Horizontal dilution of precision
	Hdop *UnionNullInt

	// Vertical dilution of precision
	Vdop *UnionNullInt

	// Number of satelites that were used to detect device position
	NumOfSatelites   *UnionNullInt
	NavigationSystem NavigationSystem

	// Angle (in degrees) between north meridian and device's moving direction (clockwise). Value is in [0, 359] degrees range
	Direction *UnionNullInt

	// Values red from analog sensors connected to analog inputs at the moment of measurement. Some analog inputs can be used for counting signals from discrete inputs
	AnalogSensors *UnionArrayAnalogSensorNull

	// Values red from liquid sensors connected to liquid sensors inputs at the moment of measurement
	LiquidSensors *UnionArrayLiquidSensorNull
}

func NewMeasurementPackageWriter(writer io.Writer, codec container.Codec, recordsPerBlock int64) (*container.Writer, error) {
	str := &MeasurementPackage{}
	return container.NewWriter(writer, codec, recordsPerBlock, str.Schema())
}

func DeserializeMeasurementPackage(r io.Reader) (*MeasurementPackage, error) {
	t := NewMeasurementPackage()

	deser, err := compiler.CompileSchemaBytes([]byte(t.Schema()), []byte(t.Schema()))
	if err != nil {
		return nil, err
	}

	err = vm.Eval(r, deser, t)
	return t, err
}

func NewMeasurementPackage() *MeasurementPackage {
	return &MeasurementPackage{}
}

func (r *MeasurementPackage) Schema() string {
	return "{\"fields\":[{\"doc\":\"IMEI of the device that sent this data\",\"name\":\"imei\",\"type\":[\"null\",\"string\"]},{\"doc\":\"Unique record identifier\",\"logicalType\":\"UUID\",\"name\":\"guid\",\"type\":\"string\"},{\"doc\":\"Client ID assigned to receiver device\",\"name\":\"clinetId\",\"type\":\"long\"},{\"doc\":\"Identifier of the data packet\",\"name\":\"packetID\",\"type\":\"long\"},{\"doc\":\"Timestamp of the measurement\",\"name\":\"measurementTimestamp\",\"type\":\"long\"},{\"doc\":\"Timestamp of receiveing the data from device\",\"name\":\"receivedTimestamp\",\"type\":\"long\"},{\"doc\":\"Device's latitude at the moment of measurement\",\"name\":\"latitude\",\"type\":[\"null\",\"double\"]},{\"doc\":\"Device's longitude at the moment of measurement\",\"name\":\"longitude\",\"type\":[\"null\",\"double\"]},{\"doc\":\"Device's speed at the moment of measurement\",\"name\":\"speed\",\"type\":[\"null\",\"int\"]},{\"doc\":\"Position dilution of precision\",\"name\":\"pdop\",\"type\":[\"null\",\"int\"]},{\"doc\":\"Horizontal dilution of precision\",\"name\":\"hdop\",\"type\":[\"null\",\"int\"]},{\"doc\":\"Vertical dilution of precision\",\"name\":\"vdop\",\"type\":[\"null\",\"int\"]},{\"doc\":\"Number of satelites that were used to detect device position\",\"name\":\"numOfSatelites\",\"type\":[\"null\",\"int\"]},{\"documentation\":\"Navigation system identifier\",\"name\":\"navigationSystem\",\"type\":{\"name\":\"NavigationSystem\",\"namespace\":\"com.projavt.ecology.schema\",\"symbols\":[\"Uknown\",\"GLONASS\",\"GPS\",\"Galileo\",\"Compass\",\"Beidou\",\"DORIS\"],\"type\":\"enum\"}},{\"doc\":\"Angle (in degrees) between north meridian and device's moving direction (clockwise). Value is in [0, 359] degrees range\",\"name\":\"direction\",\"type\":[\"null\",\"int\"]},{\"doc\":\"Values red from analog sensors connected to analog inputs at the moment of measurement. Some analog inputs can be used for counting signals from discrete inputs\",\"name\":\"analogSensors\",\"type\":[{\"items\":{\"fields\":[{\"doc\":\"Ordinal number of sensor\",\"name\":\"sensorNumber\",\"type\":\"int\"},{\"doc\":\"Value red from sensor. Meaning is this value depends on type of the input. if analog device is connected to the input, value is millivolts. If input is used for counting discrete impulses, value is the number of impulses\",\"name\":\"value\",\"type\":\"int\"}],\"name\":\"AnalogSensor\",\"namespace\":\"com.projavt.ecology.schema\",\"type\":\"record\"},\"type\":\"array\"},\"null\"]},{\"doc\":\"Values red from liquid sensors connected to liquid sensors inputs at the moment of measurement\",\"name\":\"liquidSensors\",\"type\":[{\"items\":{\"fields\":[{\"doc\":\"Ordinal number of sensor\",\"name\":\"sensorNumber\",\"type\":\"int\"},{\"doc\":\"Value is set if error occurred during reading value from liquid sensor\",\"name\":\"errorFlag\",\"type\":\"string\"},{\"doc\":\"This value is set if liquid sensor measures level of the liqid in a vessel. Otherwise value is 0\",\"name\":\"valueMillimeters\",\"type\":\"int\"},{\"doc\":\"This value is set if liquid sensor measures volume of the liqid in a vessel. Otherwise value is 0\",\"name\":\"valueLitres\",\"type\":\"int\"}],\"name\":\"LiquidSensor\",\"namespace\":\"com.projavt.ecology.schema\",\"type\":\"record\"},\"type\":\"array\"},\"null\"]}],\"name\":\"MeasurementPackage\",\"namespace\":\"com.projavt.ecology.schema\",\"type\":\"record\"}"
}

func (r *MeasurementPackage) SchemaName() string {
	return "com.projavt.ecology.schema.MeasurementPackage"
}

func (r *MeasurementPackage) Serialize(w io.Writer) error {
	return writeMeasurementPackage(r, w)
}

func (_ *MeasurementPackage) SetBoolean(v bool)    { panic("Unsupported operation") }
func (_ *MeasurementPackage) SetInt(v int32)       { panic("Unsupported operation") }
func (_ *MeasurementPackage) SetLong(v int64)      { panic("Unsupported operation") }
func (_ *MeasurementPackage) SetFloat(v float32)   { panic("Unsupported operation") }
func (_ *MeasurementPackage) SetDouble(v float64)  { panic("Unsupported operation") }
func (_ *MeasurementPackage) SetBytes(v []byte)    { panic("Unsupported operation") }
func (_ *MeasurementPackage) SetString(v string)   { panic("Unsupported operation") }
func (_ *MeasurementPackage) SetUnionElem(v int64) { panic("Unsupported operation") }
func (r *MeasurementPackage) Get(i int) types.Field {
	switch i {
	case 0:
		r.Imei = NewUnionNullString()
		return r.Imei
	case 1:
		return (*types.String)(&r.Guid)
	case 2:
		return (*types.Long)(&r.ClinetId)
	case 3:
		return (*types.Long)(&r.PacketID)
	case 4:
		return (*types.Long)(&r.MeasurementTimestamp)
	case 5:
		return (*types.Long)(&r.ReceivedTimestamp)
	case 6:
		r.Latitude = NewUnionNullDouble()
		return r.Latitude
	case 7:
		r.Longitude = NewUnionNullDouble()
		return r.Longitude
	case 8:
		r.Speed = NewUnionNullInt()
		return r.Speed
	case 9:
		r.Pdop = NewUnionNullInt()
		return r.Pdop
	case 10:
		r.Hdop = NewUnionNullInt()
		return r.Hdop
	case 11:
		r.Vdop = NewUnionNullInt()
		return r.Vdop
	case 12:
		r.NumOfSatelites = NewUnionNullInt()
		return r.NumOfSatelites
	case 13:
		return (*types.Int)(&r.NavigationSystem)
	case 14:
		r.Direction = NewUnionNullInt()
		return r.Direction
	case 15:
		r.AnalogSensors = NewUnionArrayAnalogSensorNull()
		return r.AnalogSensors
	case 16:
		r.LiquidSensors = NewUnionArrayLiquidSensorNull()
		return r.LiquidSensors

	}
	panic("Unknown field index")
}
func (r *MeasurementPackage) SetDefault(i int) {
	switch i {

	}
	panic("Unknown field index")
}
func (_ *MeasurementPackage) AppendMap(key string) types.Field { panic("Unsupported operation") }
func (_ *MeasurementPackage) AppendArray() types.Field         { panic("Unsupported operation") }
func (_ *MeasurementPackage) Finalize()                        {}

type MeasurementPackageReader struct {
	r io.Reader
	p *vm.Program
}

func NewMeasurementPackageReader(r io.Reader) (*MeasurementPackageReader, error) {
	containerReader, err := container.NewReader(r)
	if err != nil {
		return nil, err
	}

	t := NewMeasurementPackage()
	deser, err := compiler.CompileSchemaBytes([]byte(containerReader.AvroContainerSchema()), []byte(t.Schema()))
	if err != nil {
		return nil, err
	}

	return &MeasurementPackageReader{
		r: containerReader,
		p: deser,
	}, nil
}

func (r *MeasurementPackageReader) Read() (*MeasurementPackage, error) {
	t := NewMeasurementPackage()
	err := vm.Eval(r.r, r.p, t)
	return t, err
}

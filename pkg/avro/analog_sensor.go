// Code generated by github.com/actgardner/gogen-avro. DO NOT EDIT.
/*
 * SOURCE:
 *     measurementpackage.avsc
 */

package avro

import (
	"github.com/actgardner/gogen-avro/compiler"
	"github.com/actgardner/gogen-avro/container"
	"github.com/actgardner/gogen-avro/vm"
	"github.com/actgardner/gogen-avro/vm/types"
	"io"
)

type AnalogSensor struct {

	// Ordinal number of sensor
	SensorNumber int32

	// Value red from sensor. Meaning is this value depends on type of the input. if analog device is connected to the input, value is millivolts. If input is used for counting discrete impulses, value is the number of impulses
	Value int32
}

func NewAnalogSensorWriter(writer io.Writer, codec container.Codec, recordsPerBlock int64) (*container.Writer, error) {
	str := &AnalogSensor{}
	return container.NewWriter(writer, codec, recordsPerBlock, str.Schema())
}

func DeserializeAnalogSensor(r io.Reader) (*AnalogSensor, error) {
	t := NewAnalogSensor()

	deser, err := compiler.CompileSchemaBytes([]byte(t.Schema()), []byte(t.Schema()))
	if err != nil {
		return nil, err
	}

	err = vm.Eval(r, deser, t)
	return t, err
}

func NewAnalogSensor() *AnalogSensor {
	return &AnalogSensor{}
}

func (r *AnalogSensor) Schema() string {
	return "{\"fields\":[{\"doc\":\"Ordinal number of sensor\",\"name\":\"sensorNumber\",\"type\":\"int\"},{\"doc\":\"Value red from sensor. Meaning is this value depends on type of the input. if analog device is connected to the input, value is millivolts. If input is used for counting discrete impulses, value is the number of impulses\",\"name\":\"value\",\"type\":\"int\"}],\"name\":\"AnalogSensor\",\"namespace\":\"com.projavt.ecology.schema\",\"type\":\"record\"}"
}

func (r *AnalogSensor) SchemaName() string {
	return "com.projavt.ecology.schema.AnalogSensor"
}

func (r *AnalogSensor) Serialize(w io.Writer) error {
	return writeAnalogSensor(r, w)
}

func (_ *AnalogSensor) SetBoolean(v bool)    { panic("Unsupported operation") }
func (_ *AnalogSensor) SetInt(v int32)       { panic("Unsupported operation") }
func (_ *AnalogSensor) SetLong(v int64)      { panic("Unsupported operation") }
func (_ *AnalogSensor) SetFloat(v float32)   { panic("Unsupported operation") }
func (_ *AnalogSensor) SetDouble(v float64)  { panic("Unsupported operation") }
func (_ *AnalogSensor) SetBytes(v []byte)    { panic("Unsupported operation") }
func (_ *AnalogSensor) SetString(v string)   { panic("Unsupported operation") }
func (_ *AnalogSensor) SetUnionElem(v int64) { panic("Unsupported operation") }
func (r *AnalogSensor) Get(i int) types.Field {
	switch i {
	case 0:
		return (*types.Int)(&r.SensorNumber)
	case 1:
		return (*types.Int)(&r.Value)

	}
	panic("Unknown field index")
}
func (r *AnalogSensor) SetDefault(i int) {
	switch i {

	}
	panic("Unknown field index")
}
func (_ *AnalogSensor) AppendMap(key string) types.Field { panic("Unsupported operation") }
func (_ *AnalogSensor) AppendArray() types.Field         { panic("Unsupported operation") }
func (_ *AnalogSensor) Finalize()                        {}

type AnalogSensorReader struct {
	r io.Reader
	p *vm.Program
}

func NewAnalogSensorReader(r io.Reader) (*AnalogSensorReader, error) {
	containerReader, err := container.NewReader(r)
	if err != nil {
		return nil, err
	}

	t := NewAnalogSensor()
	deser, err := compiler.CompileSchemaBytes([]byte(containerReader.AvroContainerSchema()), []byte(t.Schema()))
	if err != nil {
		return nil, err
	}

	return &AnalogSensorReader{
		r: containerReader,
		p: deser,
	}, nil
}

func (r *AnalogSensorReader) Read() (*AnalogSensor, error) {
	t := NewAnalogSensor()
	err := vm.Eval(r.r, r.p, t)
	return t, err
}
